I"Á<p>This is the second post on the Go module series, which highlights Grabâ€™s experience working with Go modules in a multi-module monorepo. In this article, weâ€™ll focus on suggested solutions for catching unexpected changes to the <code class="language-plaintext highlighter-rouge">go.mod</code> file and addressing dependency issues. Weâ€™ll also cover automatic upgrades and other learnings uncovered from the initial obstacles in using Go modules.</p>

<h2 id="vendoring-process-issues">Vendoring Process Issues</h2>

<p>Our previous vendoring process fell solely on the developer who wanted to add or update a dependency. However, it was often the case that the developer came across many unexpected changes due to previous vendoring attempts, accidental imports and changes to dependencies.</p>

<p>The developer would then have to resolve these issues before being able to make a change, costing time and causing frustration with the process. It became clear that it wasnâ€™t practical to expect the developer to catch all of the potential issues while vendoring, especially since Go modules itself was new and still in development.</p>

<h2 id="avoiding-unexpected-changes">Avoiding Unexpected Changes</h2>

<p>Reluctantly, we added a check to our CI process which ran on every merge request. This helped ensure that there are no unexpected changes required to go mod. This added time to every build and often flagged a failure, but it saved a lot of post-merge hassle. We then realised that we should have done this from the beginning.</p>

<p>Since we hadnâ€™t enabled Go modules for builds yet, we couldnâ€™t rely on the <a href="https://godoc.org/cmd/go%23hdr-Maintaining_module_requirements"><code class="language-plaintext highlighter-rouge">\mod=readonly</code></a> flag. We implemented the check by running <code class="language-plaintext highlighter-rouge">go mod vendor</code> and then checking the resulting difference.</p>

<p>If there were any changes to <code class="language-plaintext highlighter-rouge">go.mod</code> or the vendor directory, the merge request would get rejected. This worked well in ensuring the integrity of our <code class="language-plaintext highlighter-rouge">go.mod</code>.</p>

<h2 id="roadblocks-and-learnings">Roadblocks and Learnings</h2>

<p>However, as this was the first time we were using Go modules on our CI system, it uncovered some more problems.</p>

<h3 id="private-repository-access">Private Repository Access</h3>

<p>There was the problem of accessing private repositories. We had to ensure that the CI system was able to clone all of our private repositories as well as the main monorepo, by adding the relevant SSH deploy keys to the repository.</p>

<h3 id="false-positives">False Positives</h3>

<p>The check sometimes fired <code class="language-plaintext highlighter-rouge">false positives</code> - detecting a go mod failure when there were no changes. This was often due to network issues, especially when the modules are hosted by less reliable third-party servers. This is somewhat solved in Go 1.13 onwards with the introduction of <a href="https://golang.org/cmd/go/%23hdr-Module_downloading_and_verification">proxy servers</a>, but our workaround was simply to retry the command several times.</p>

<p>We also avoided adding dependencies hosted by a domain that we havenâ€™t seen before, unless absolutely necessary.</p>

<h3 id="inconsistent-go-versions">Inconsistent Go Versions</h3>

<p>We found several inconsistencies between Go versions - running go mod vendor on one Go version gave different results to another. One example was a <a href="https://github.com/golang/go/issues/29278">change to the checksums</a>. These inconsistencies are less common now, but still remain between Go 1.12 and later versions. The only solution is to stick to a single version when running the vendoring process.</p>

<h2 id="automated-upgrades">Automated Upgrades</h2>

<p>There are benefits to using Go modules for vendoring. Itâ€™s faster than previous solutions, better supported by the community and part of the language, so it doesnâ€™t require any extra tools or wrappers to use it.</p>

<p>One of the most useful benefits from using Go modules is that it enables automated upgrades of dependencies in the go.mod file - and it becomes more useful as more third-party modules adopt Go modules and semantic versioning.</p>

<div class="post-image-section"><figure>
  <img src="/img/go-module-a-guide-for-monorepos-part-2/image1.png" alt="Automated updates workflow" />
  <figcaption align="middle"><i>Automated updates workflow</i></figcaption>
</figure></div>

<p>We call our solution for automating updates at Grab the AutoVend Bot. It is built around a single Go command, <code class="language-plaintext highlighter-rouge">go list -m -u all</code>, which finds and lists available updates to the dependencies listed in <code class="language-plaintext highlighter-rouge">go.mod</code> (add <code class="language-plaintext highlighter-rouge">\json</code> for JSON output). We integrated the bot with our development workflow and change-request system to take the output from this command and create merge requests automatically, one per update.</p>

<p>Once the merge request is approved (by a human, after verifying the test results), the bot would push the change. We have hundreds of dependencies in our main monorepo module, so weâ€™ve scheduled it to run a small number each day so weâ€™re not overwhelmed.</p>

<p>By reducing the manual effort required to update dependencies to almost nothing, we have been able to apply hundreds of updates to our dependencies, and ensure our most critical dependencies are on the latest version. This not only helps keep our dependencies free from bugs and security flaws, but it makes future updates far easier and less impactful by reducing the set of changes needed.</p>

<h2 id="in-summary">In Summary</h2>

<p>Using Go modules for vendoring has given us valuable and low-risk exposure to the feature. We have been able to detect and solve issues early, without affecting our regular builds, and develop tooling thatâ€™ll help us in future.</p>

<p>Although Go modules is part of the standard Go toolchain, it shouldnâ€™t be viewed as a complete <em>off the shelf</em> solution that can be dropped into a codebase, especially a monorepo.</p>

<p>Like many other Go tools, the Modules feature comprises many small, focused tools that work best when combined together with other code. By embracing this concept and leveraging things like go list, go mod graph and go mod vendor, Go modules can be made to integrate into existing workflows, and deliver the benefits of structured versioning and reproducible builds.</p>

<p>I hope you have enjoyed this article on using Go modules and vendoring within a monorepo.</p>

<h2 id="join-us">Join us</h2>

<p>Grab is a leading superapp in Southeast Asia, providing everyday services that matter to consumers. More than just a ride-hailing and food delivery app, Grab offers a wide range of on-demand services in the region, including mobility, food, package and grocery delivery services, mobile payments, and financial services across over 400 cities in eight countries.</p>

<p>Powered by technology and driven by heart, our mission is to drive Southeast Asia forward by creating economic empowerment for everyone. If this mission speaks to you, <a href="https://grab.careers/">join our team</a> today!</p>

<h4 id="credits">Credits</h4>
<p><em>The cute Go gopher logo for this blogâ€™s cover image was inspired by Renee Frenchâ€™s original work.</em></p>
:ET