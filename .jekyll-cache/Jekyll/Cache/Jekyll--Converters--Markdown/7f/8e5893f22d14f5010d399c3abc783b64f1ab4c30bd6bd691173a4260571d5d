I"ãA<h1 id="how-we-designed-the-quotas-microservice-to-prevent-resource-abuse">How We Designed the Quotas Microservice to Prevent Resource Abuse</h1>

<p>As the business has grown, Grab‚Äôs infrastructure has changed from a monolithic service to dozens of microservices. And that number will soon be expressed in hundreds. As our engineering team grows in parallel, having a microservice framework provides benefits such as higher flexibility, productivity, security, and system reliability. Teams define Service Level Agreements (SLA) with their clients, meaning specification of their service‚Äôs API interface and its related performance metrics. As long as the SLAs are maintained, individual teams can focus on their services without worrying about breaking other services.</p>

<p>However, migrating to a microservice framework can be tricky - due to the the large number of services and having to communicate between them. Problems that are simple to solve or don‚Äôt exist for a monolithic service such as service discovery, security, load balancing, monitoring, and rate limiting are challenging for a microservice based framework. Reliable, scalable, and high performing solutions for common system level issues are essential for microservice success, and there is a Grab-wide initiative to provide those common solutions.</p>

<p>As an important component of the initiative, we wrote a microservice called Quotas, a highly scalable API request rate limiting solution to mitigate the problems of service abuse and cascading service failures. In this article, we discuss the challenges Quotas addresses, how we designed it, and the end results.¬†</p>

<h2 id="what-quotas-try-to-address">What Quotas Try to Address</h2>

<p>Rate limiting is a well known concept used by many companies for years.¬†For example, telecommunication companies and content providers frequently throttle requests from abusive users by using popular rate-limiting algorithms such as leaky bucket, fixed window, sliding log, sliding window, etc. All of these avoid resource abuse and protect important resources. Companies have also developed rate limiting solutions for inter-service communications, such as Doorman (<a href="https://github.com/youtube/doorman/blob/master/doc/design.md">https://github.com/youtube/doorman/blob/master/doc/design.md</a>), Ambassador (<a href="https://www.getambassador.io/reference/services/rate-limit-service">https://www.getambassador.io/reference/services/rate-limit-service</a>), etc, just to name a few.</p>

<p>Rate limiting can be enforced locally or globally. Local rate limiting means an instance accumulates API request information and makes decisions locally, with no coordination required. For example, a local rate limiting strategy can specify that each service instance can serve up to 1000 requests per second for an API, and the service instance will keep a local time-aware request counter. Once the number of received requests exceeds the threshold, it will reject new requests immediately until the next time bucket with available quota. Global rate limiting means multiple instances share the same enforcement policy. With global rate limiting, regardless of the service instance a client calls, it will be¬†subjected¬†to the same global API quota. Global rate limiting ensures there is a global view and it is preferred in many scenarios. In a cloud context, with auto scaling policy setup, the number of instances for a service can increase significantly during peak traffic hours. If only local rate limiting is enforced, the accumulative effect can still put great pressure on critical resources such as databases, network, or downstream services and the cumulative effects can cause service failures.</p>

<p>However, to support global rate limiting in a distributed environment is not easy, and it becomes even more challenging when the number of services and instances increases. To support a global view, Quotas needs to know how many requests a client service A (i.e., service A is a client of Quotas) is getting now on an endpoint comparing to the defined thresholds. If the number of requests is already over the thresholds, Quotas service should help to block a new request before service A executes its main logic. By doing that, Quotas service helps service A protect resources such as CPU, memory, database, network, and its downstream services, etc. To track the global request counts on service endpoints, a centralised data store such as Redis or Dynamo is generally used for the aggregation and decision making. In addition, decision latency and scalability become major concerns if each request needs to make a call to the rate limiting service (i.e., Quotas) to¬†decide¬†if the request should be throttled. And if that is the case, the rate limiting service will be on the critical path of every request and it will be a major concern for services. That is the scenario we absolutely wanted to avoid when designing Quotas service.</p>

<h2 id="designing-quotas">Designing Quotas</h2>

<p>Quotas ensures Grab internal services can guarantee their service level agreement (SLA) by throttling ‚Äúexcessive‚Äù API requests made to them, thereby avoiding cascading failures . By rejecting these calls early through throttling, services can be protected from depleting critical resources such as¬†databases, computation resources, etc.</p>

<p>The two main goals for Quotas are:</p>

<ul>
  <li>
    <p>Help client services throttle excessive API requests in a timely fashion.</p>
  </li>
  <li>
    <p>Minimise latency impacts on client services, i.e., client services should only see negligible latency increase on API response time.</p>
  </li>
</ul>

<p>We followed these design guidelines:</p>

<ol>
  <li>
    <p>Providing a thin client implementation. Quotas service should keep most of the processing logic at the service side. Once we release a client SDK, it‚Äôs very hard to track who‚Äôs using what version and to update every client service with a new client SDK version. Also, more complex client side logic increases the chances of introducing bugs.</p>
  </li>
  <li>
    <p>To allow scaling of Quotas service, we use an asynchronous processing pipeline instead of a synchronous one (i.e., client service makes calls Quotas for every API request). By asynchronously processing events, a client service can immediately decide whether to throttle an API request when it comes in, without delaying the response too much.</p>
  </li>
  <li>
    <p>Allowing for horizontal scaling through config changes. This is very important since the goal is to onboard all Grab internal services.</p>
  </li>
</ol>

<p>Figure 1 is a high-level system diagram for Quotas‚Äô client and server side interactions. Kafka sits at the core of the system design. Kafka is an open-source distributed streaming platform under the Apache license and it‚Äôs widely adopted by the industry (<a href="https://kafka.apache.org/intro">https://kafka.apache.org/intro</a>). Kafka is used in Quotas system design for the following purposes:</p>

<ol>
  <li>
    <p>Quotas client services (i.e., services B and C in Figure 1) send API usage information through a dedicated Kafka topic and Quotas service consumes the events and performs its business logic.</p>
  </li>
  <li>
    <p>Quotas service sends rate-limiting decisions through application-specific Kafka topics and the Quotas client SDKs running on the client service instances consume the rate-limiting events and update the local in-memory cache for rate-limiting decisions. For example, Quotas service uses topic names such as ‚Äúrate-limiting-service-b‚Äù for rate-limiting decisions with service B and ‚Äúrate-limiting-service-c‚Äù for service C.</p>
  </li>
  <li>
    <p>An archiver is running with Kafka to archive the events to AWS S3 buckets for additional analysis.</p>
  </li>
</ol>

<div class="post-image-section">
  <img alt="Figure 1: Quotas High-level System Design" src="/img/quotas-service/image_0.jpg" />
  <small class="post-image-caption">Figure 1: Quotas High-level System Design</small>
</div>

<p>The details of Quotas client side logic is shown in Figure 2 using service B as an example. As it shows, when a request comes in (e.g., from service A), service B will perform the following logic:</p>

<ol>
	<li>Quotas middleware running with service B
		<ol type="a">
		  <li>intercepts the request and calls Quotas client SDK for the rate limiting decision based on API and client information.
		  	<ol type="i">
		  		<li>If it throttles the request, service B returns a response code indicating the request is throttled.</li>
		  		<li>If it doesn't throttle the request, service B handles it with its normal business logic.</li>
		  	</ol>
		  </li>
		  <li>asynchronously sends the API request information to a Kafka topic for processing.</li>
		</ol>
	</li>
	<li>Quotas client SDK running with service B
		<ol>
			<li>consumes the application-specific rate-limiting Kafka stream and updates its local in-memory cache for new rate-limiting decisions. For example, if the previous decision is true (i.e., enforcing rate limiting), and the new decision from the Kafka stream is false, the local in-memory cache will be updated to reflect the change. After that, if a new request comes in from service A, it will be allowed to go through and served by service B.</li>
			<li>provides a single public API to read the rate limiting decision based on API and client information. This public API reads the decisions from its local in-memory cache.</li>
		</ol>
	</li>
</ol>

<div class="post-image-section">
  <img alt="Figure 2: Quotas Client Side Logic" src="/img/quotas-service/image_1.jpg" />
  <small class="post-image-caption">Figure 2: Quotas Client Side Logic</small>
</div>

<p>Figure 3 shows the details of Quotas server side logic. It performs the following business logic:</p>

<ul>
  <li>
    <p>Consumes the Kafka stream topic for API request information</p>
  </li>
  <li>
    <p>Performs aggregations on the API usages</p>
  </li>
  <li>
    <p>Stores the stats in a Redis cluster periodically</p>
  </li>
  <li>
    <p>Makes a rate-limiting decision periodically</p>
  </li>
  <li>
    <p>Sends the rate-limiting decisions to an application-specific Kafka stream</p>
  </li>
  <li>
    <p>Sends the stats to DataDog for monitoring and alerting periodically</p>
  </li>
</ul>

<p>In addition, an admin UI is available for service owners to update thresholds and the changes are picked up immediately for the upcoming rate-limiting decisions.</p>

<div class="post-image-section">
  <img alt="Figure 3: Quotas Server Side Logic" src="/img/quotas-service/image_2.jpg" />
  <small class="post-image-caption">Figure 3: Quotas Server Side Logic</small>
</div>

<h2 id="implementation-decisions-and-optimisations">Implementation Decisions and Optimisations</h2>

<p>On the client service side (service B in the above diagrams), the Quotas client SDK is initialised when service B instance is initialised. The Quotas client SDK is a wrapper that consumes Kafka rate-limiting events and writes/reads the in-memory cache. It exposes a single API to check the rate-limiting decisions on a client with a given API method. Also, service B is hooked up with Quotas middleware to intercept API requests. Internally, it calls the Quotas client SDK API to determine if it should allow/reject the requests before the actual business logic. Currently, Quotas middleware supports both¬†<a href="https://grpc.io/">gRPC</a>¬†and REST protocols.</p>

<p>Quotas utilises a company-wide streaming solution called Sprinkler for the Kafka stream Producer and Consumer implementations. It provides streaming SDKs built on top of¬†<a href="https://github.com/Shopify/sarama">sarama</a>¬†(an MIT-license Go library for Apache Kafka), providing asynchronous event sending/consuming, retry, and circuit breaking capabilities.</p>

<p>Quotas provides throttling capabilities based on the sliding window algorithm on the 1-second and 5-second levels. To support extremely high TPS demands, most of Quotas intermediate operations are designed to be done asynchronously. Internal benchmarks show the delay for enforcing a rate-limiting decision is up to 200 milliseconds. By combining 1-second and 5-second level settings, client services can more effectively throttle requests.</p>

<p>During system¬†implementation, we find¬†that if Quotas instances make a call to the Redis cluster every time it receives an event from the Kafka API usage stream, the Redis cluster will quickly become a bottleneck due to the amount of calculations. By aggregating API usage stats locally in-memory and¬†calling¬†Redis instances periodically (i.e., every 50 ms), we can significantly reduce Redis usage and still keep the overall decision latency at a relatively low level. In addition, we designed the hash keys in a way to make sure requests are evenly distributed across Redis instances.</p>

<h2 id="evaluation-and-benchmarks">Evaluation and Benchmarks</h2>

<p>We did multiple rounds of load tests, both before and after launching Quotas, to evaluate its performance and find potential scaling bottlenecks. After the optimisation efforts, Quotas now gracefully handles 200k peak production TPS. More importantly, critical system resource usage for Quotas‚Äô application server, Redis and Kafka are still at a relatively low level, suggesting that Quotas can support much higher TPS before the need to scale up.</p>

<p>Quotas current production settings are:</p>

<ol>
  <li>
    <p>12 c5.2xlarge (8 vCPU, 16GB) AWS EC2 instances</p>
  </li>
  <li>
    <p>6 cache.m4.large (2 vCPU, 6.42GB, master-slave) AWS ElasticCaches</p>
  </li>
  <li>
    <p>Shared Kafka cluster with other application topics</p>
  </li>
</ol>

<p>Figures 4 &amp; 5 show a typical day‚Äôs CPU usage for the Quotas application server and Redis Cache respectively. With 200k peak TPS, Quotas handles the load with peak application server CPU usage at about 20% and Redis CPU usage of 15%. Due to the nature of Quotas data usage, most of the data stored in Redis cache is time sensitive and stored with time-to-live (TTL) values.</p>

<p>However, because of how Redis expires keys (<a href="https://redis.io/commands/expire">https://redis.io/commands/expire</a>) and the amount of time-sensitive data Quotas stores in Redis, we have implemented a proprietary cron job to actively garbage collect expired Redis keys. By running the cron job every 15 minutes, Quotas keeps the Redis memory usage at a low level.</p>

<div class="post-image-section">
  <img alt="Figure 4: Quotas CPU Usage" src="/img/quotas-service/image_3.png" />
  <small class="post-image-caption">Figure 4: Quotas CPU Usage</small>
</div>

<div class="post-image-section">
  <img alt="Figure 5: Quotas Redis CPU Usage" src="/img/quotas-service/image_4.png" />
  <small class="post-image-caption">Figure 5: Quotas Redis CPU Usage</small>
</div>

<p>We have conducted load tests to identify the potential issues for scaling Quotas. The tests have shown that we can horizontally scale Quotas to support extremely high TPS using only configuration changes:</p>

<ol>
  <li>
    <p>Kafka is well known for its high throughput, low-latency, high scalability characteristics. By either increasing the number of partitions on Quotas API usage topic or adding more Kafka nodes, the system can evenly distribute and handle additional load.</p>
  </li>
  <li>
    <p>All Quotas application servers form a consumer group (CG) to consume the Kafka API usage topic (partitioned based on the number of instance expectations). Whenever an instance starts or goes offline, the topic partitions are re-distributed among the application servers. This allows balanced topic partition consumptions and thus somewhat evenly distributed application server CPU and memory usages.¬†</p>
  </li>
  <li>
    <p>We have also implemented a consistent hashing based algorithm to support multiple Redis instances. It supports easy Redis instances addition or removal by configuration changes. With well chosen hash keys, load can be evenly distributed to the Redis instances.</p>
  </li>
</ol>

<p>With the above design and implementations, all the critical Quotas components can be easily scaled and extended when a bottleneck occurs either at Kafka, application server, or Redis levels.</p>

<h2 id="roadmap-for-quotas">Roadmap for Quotas</h2>

<p>Quotas is currently used by more than a dozen internal Grab services, and soon all Grab internal services will use it.</p>

<p>Quotas is part of the company-wide ServiceMesh effort to handle service discovery, load balancing, circuit breaker, retry, health monitoring, rate-limiting, security, etc. consistently across all Grab services.</p>
:ET