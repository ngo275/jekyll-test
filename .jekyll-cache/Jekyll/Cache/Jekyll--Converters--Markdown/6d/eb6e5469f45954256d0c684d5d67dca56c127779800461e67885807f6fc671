I"n1<p>While working on Grab’s Common Data Service (CDS), there was a need to implement client side load balancing between CDS clients and servers. However, I kept encountering persistent connection issues with AWS Elastic Load Balancers (ELB). Hence, I decided to focus my attention on using DNS discovery, as ELB’s performance is not optimal and the unpredictable scaling events could further affect the stability of our systems. At the same time, I didn’t want to have to manage the details of DNS TTL, different protocols, etc. Thus, the search for a reliable DNS library began.</p>

<p>Eventually, I found this package after some research: <a href="https://github.com/benschw/srv-lb">https://github.com/benschw/srv-lb</a>. It looked pretty neat and provides round-robin routing for IP addresses behind a DNS domain, which is exactly what I wanted.</p>

<p>During my tests of the round-robin function, it turned out the round-robin didn’t work… We have 7 servers behind our <a href="https://github.com/coreos/etcd">etcd</a> domain but when I tried with the package, it gave me the following sequence of IP addresses:</p>

<blockquote>
  <p>1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7 -&gt; 1 -&gt; 1…</p>
</blockquote>

<p>It turns out that there was a bug in that library, which I’ve fixed by submitting a <a href="https://github.com/benschw/srv-lb/pull/3">pull request</a>.</p>

<p>We do implement some round-robin logic in our code too, which can be tricky to get right at times. Read on for a summary of our learnings from the different ways of doing round-robin.</p>

<h3 id="round-robin-with-mutex">Round-robin with Mutex</h3>

<p>This is the simplest approach you can use to implement round-robin logic.</p>

<p>Basically, all you need is an array and a counter in your programme and the use of a lock to protect usage. Here’s some example code in Golang to illustrate the idea:</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"sync"</span>

<span class="c">// RoundRobin ...</span>
<span class="k">type</span> <span class="n">RoundRobin</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">sync</span><span class="o">.</span><span class="n">Mutex</span>

    <span class="n">current</span> <span class="kt">int</span>
    <span class="n">pool</span>    <span class="p">[]</span><span class="kt">int</span>
<span class="p">}</span>

<span class="c">// NewRoundRobin ...</span>
<span class="k">func</span> <span class="n">NewRoundRobin</span><span class="p">()</span> <span class="o">*</span><span class="n">RoundRobin</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="n">RoundRobin</span><span class="p">{</span>
        <span class="n">current</span><span class="o">:</span> <span class="m">0</span><span class="p">,</span>
        <span class="n">pool</span><span class="o">:</span>    <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">5</span><span class="p">},</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c">// Get ...</span>
<span class="k">func</span> <span class="p">(</span><span class="n">r</span> <span class="o">*</span><span class="n">RoundRobin</span><span class="p">)</span> <span class="n">Get</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="n">r</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
    <span class="k">defer</span> <span class="n">r</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">current</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">pool</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">r</span><span class="o">.</span><span class="n">current</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">current</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">pool</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="n">result</span> <span class="o">:=</span> <span class="n">r</span><span class="o">.</span><span class="n">pool</span><span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">current</span><span class="p">]</span>
    <span class="n">r</span><span class="o">.</span><span class="n">current</span><span class="o">++</span>
    <span class="k">return</span> <span class="n">result</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Looks pretty simple? That’s because only one action was defined for this <code class="language-plaintext highlighter-rouge">struct</code> – there is nothing complicated to worry about. However, if you want to add <code class="language-plaintext highlighter-rouge">Set</code> / <code class="language-plaintext highlighter-rouge">Update</code> methods to this <code class="language-plaintext highlighter-rouge">struct</code>, be sure to pay more attention to the usage of locks.</p>

<h3 id="round-robin-with-your-favourite-channel">Round-robin with Your Favourite Channel</h3>

<p>Another approach of implementing a round-robin pool is to use goroutines and channels. The programme is a little bit more complex:</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"time"</span>

<span class="k">const</span> <span class="n">timeout</span> <span class="o">=</span> <span class="m">100</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Millisecond</span>

<span class="c">// RoundRobin ...</span>
<span class="k">type</span> <span class="n">RoundRobin</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">current</span> <span class="kt">int</span>
    <span class="n">pool</span>    <span class="p">[]</span><span class="kt">int</span>

    <span class="n">requestQ</span> <span class="k">chan</span> <span class="k">chan</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="c">// NewRoundRobin ...</span>
<span class="k">func</span> <span class="n">NewRoundRobin</span><span class="p">()</span> <span class="o">*</span><span class="n">RoundRobin</span> <span class="p">{</span>
    <span class="n">r</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">RoundRobin</span><span class="p">{</span>
        <span class="n">current</span><span class="o">:</span>  <span class="m">0</span><span class="p">,</span>
        <span class="n">pool</span><span class="o">:</span>     <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">5</span><span class="p">},</span>
        <span class="n">requestQ</span><span class="o">:</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="k">chan</span> <span class="kt">int</span><span class="p">),</span>
    <span class="p">}</span>
    <span class="k">go</span> <span class="n">r</span><span class="o">.</span><span class="n">balancer</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">r</span>
<span class="p">}</span>

<span class="c">// Get ...</span>
<span class="k">func</span> <span class="p">(</span><span class="n">r</span> <span class="o">*</span><span class="n">RoundRobin</span><span class="p">)</span> <span class="n">Get</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="n">output</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span>
    <span class="k">select</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">r</span><span class="o">.</span><span class="n">requestQ</span> <span class="o">&lt;-</span> <span class="n">output</span><span class="o">:</span>
        <span class="k">return</span> <span class="o">&lt;-</span><span class="n">output</span>
    <span class="k">case</span> <span class="o">&lt;-</span><span class="n">time</span><span class="o">.</span><span class="n">After</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span><span class="o">:</span>
        <span class="c">// Timeout</span>
        <span class="k">return</span> <span class="o">-</span><span class="m">1</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c">// balancer ...</span>
<span class="k">func</span> <span class="p">(</span><span class="n">r</span> <span class="o">*</span><span class="n">RoundRobin</span><span class="p">)</span> <span class="n">balancer</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="k">select</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">output</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">r</span><span class="o">.</span><span class="n">requestQ</span><span class="o">:</span>
            <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">current</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">pool</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">r</span><span class="o">.</span><span class="n">current</span> <span class="o">=</span> <span class="m">0</span>
            <span class="p">}</span>
            <span class="n">output</span> <span class="o">&lt;-</span> <span class="n">r</span><span class="o">.</span><span class="n">pool</span><span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">current</span><span class="p">]</span>
            <span class="n">r</span><span class="o">.</span><span class="n">current</span><span class="o">++</span>
        <span class="c">// other cases can be added here</span>
        <span class="c">// e.g. case change := &lt;-r.watch:</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The benefits of this approach:</p>

<ul>
  <li>More granular control over operation timeouts. In the mutex approach, there isn’t a way for you to cancel an operation if it takes too long to complete.</li>
  <li><code class="language-plaintext highlighter-rouge">balancer</code> is the one centralised place that controls all your actions. If you add more operations to this struct, just add more cases there and you do not need to worry about the granularity of your locks.</li>
</ul>

<p>The drawbacks of this approach:</p>

<ul>
  <li>Code is more complicated.</li>
  <li>Each op takes more time to complete, in the order of nanoseconds, because there are channel creations with each time.</li>
</ul>

<h3 id="summary">Summary</h3>

<p>Based on your requirements, pick the preferred method of implementing a simple logic like round-robin.</p>

<p>I would pick the mutex implementation for resource fetching and goroutine implementation for work load balancing. Leave a comment if you wish to discuss. I would love to hear your views!</p>

<p><strong>References:</strong></p>

<ul>
  <li><a href="https://talks.golang.org/2010/io/balance.go">https://talks.golang.org/2010/io/balance.go</a></li>
  <li><a href="https://github.com/mindreframer/golang-stuff/blob/master/github.com/youtube/vitess/go/pools/roundrobin.go">https://github.com/mindreframer/golang-stuff/blob/master/github.com/youtube/vitess/go/pools/roundrobin.go</a></li>
</ul>
:ET