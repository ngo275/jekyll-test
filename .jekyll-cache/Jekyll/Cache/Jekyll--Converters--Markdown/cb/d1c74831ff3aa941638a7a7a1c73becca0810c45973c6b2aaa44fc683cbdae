I"¹3<p><a href="https://github.com/golang/go/wiki/Modules%23quick-start">Go modules</a> are a new feature in Go for versioning packages and managing dependencies. It has been almost 2 years in the making, and itâ€™s finally production-ready in the Go 1.14 release early this year. Go recommends using single-module repositories by default, and warns that multi-module repositories require great care.</p>

<p>At Grab, we have a large monorepo and changing from our existing monorepo structure has been an interesting and humbling adventure. We faced serious obstacles to fully adopting Go modules. This series of articles describes Grabâ€™s experience working with Go modules in a multi-module monorepo, the challenges we faced along the way, and the solutions we came up with.</p>

<p>To fully appreciate Grabâ€™s journey in using Go Modules, itâ€™s important to learn about the beginning of our vendoring process.</p>

<h2 id="native-support-for-vendoring-using-the-vendor-folder">Native Support for Vendoring Using the Vendor Folder</h2>

<p>With Go 1.5 came the concept of the <code class="language-plaintext highlighter-rouge">vendor</code> folder, a new package discovery method, providing native support for vendoring in Go for the first time.</p>

<p>With the <code class="language-plaintext highlighter-rouge">vendor</code> folder, projects influenced the lookup path simply by copying packages into a <code class="language-plaintext highlighter-rouge">vendor</code> folder nested at the project root. Go uses these packages before traversing the <code class="language-plaintext highlighter-rouge">GOPATH</code> root, which allows a monorepo structure to vendor packages within the same repo as if they were 3rd-party libraries. This enabled <code class="language-plaintext highlighter-rouge">go build</code> to work consistently without any need for extra scripts or env var modifications.</p>

<h3 id="initial-obstacles">Initial Obstacles</h3>

<p>There was no official command for managing the <code class="language-plaintext highlighter-rouge">vendor</code> folder, and even copying the files in the <code class="language-plaintext highlighter-rouge">vendor</code> folder manually was common.</p>

<p>At Grab, different teams took different approaches. This meant that we had multiple version manifests and lock files for our monorepoâ€™s vendor folder. It worked fine as long as there were no conflicts. At this time very few 3rd-party libraries were using proper tagging and semantic versioning, so it was worse because the lock files were largely a jumble of commit hashes and timestamps.</p>

<div class="post-image-section"><figure>
  <img src="/img/go-module-a-guide-for-monorepos-part-1/image2.png" alt="Jumbled commit hashes and timestamps" />
  <figcaption align="middle"><i>Jumbled commit hashes and timestamps</i></figcaption>
</figure></div>

<p>As a result of the multiple versions and lock files, the vendor directory was not reproducible, and we couldnâ€™t be sure what versions we had in there.</p>

<h3 id="temporary-relief">Temporary Relief</h3>

<p>We eventually settled on using <a href="https://github.com/Masterminds/glide">Glide</a>, and standardised our vendoring process. Glide gave us a reproducible, verifiable <code class="language-plaintext highlighter-rouge">vendor</code> folder for our dependencies, which worked up until we switched to Go modules.</p>

<h2 id="vendoring-using-go-modules">Vendoring Using Go Modules</h2>

<p>I first heard about Go modules from Russ Coxâ€™s talk at <a href="https://2018.gophercon.sg">GopherCon Singapore</a> in 2018, and soon after started working on adopting modules at Grab, which was to manage our existing <code class="language-plaintext highlighter-rouge">vendor</code> folder.</p>

<p>This allowed us to align with the official Go toolchain and familiarise ourselves with Go modules while the feature matured.</p>

<h3 id="switching-to-go-modules">Switching to Go Modules</h3>

<p>Go modules introduced a <code class="language-plaintext highlighter-rouge">go mod vendor</code> command for exporting all dependencies from <code class="language-plaintext highlighter-rouge">go.mod</code> into <code class="language-plaintext highlighter-rouge">vendor</code>. We didnâ€™t plan to enable Go modules for builds at this point, so our builds continued to run exactly as before, indifferent to the fact that the vendor directory was created using <code class="language-plaintext highlighter-rouge">go mod</code>.</p>

<p>The initial task to switch to <code class="language-plaintext highlighter-rouge">go mod vendor</code> was relatively straightforward as listed here:</p>

<ol>
  <li>Generated a <code class="language-plaintext highlighter-rouge">go.mod</code> file from our <code class="language-plaintext highlighter-rouge">glide.yaml</code> dependencies. This was scripted so it could be kept up to date without manual effort.</li>
  <li>Replaced the vendor directory.</li>
  <li>Committed the changes.</li>
  <li>Used <code class="language-plaintext highlighter-rouge">go mod</code> instead of glide to manage the vendor folder.</li>
</ol>

<p>The change was extremely large (due to differences in how glide and <code class="language-plaintext highlighter-rouge">go mod</code> handled the pruning of unused code), but equivalent in terms of Go code. However, there were some additional changes needed besides porting the version file.</p>

<h3 id="addressing-incompatible-dependencies">Addressing Incompatible Dependencies</h3>

<p>Some of our dependencies were not yet compatible with Go modules, so we had to use Go moduleâ€™s replace directive to substitute them with a working version.</p>

<p>A more complex issue was that parts of our codebase relied on nested vendor directories, and had dependencies that were incompatible with the top level. The <code class="language-plaintext highlighter-rouge">go mod vendor</code> command attempts to include all code nested under the root path, whether or not they have used a sub-vendor directory, so this led to conflicts.</p>

<h4 id="problematic-paths">Problematic Paths</h4>

<p>Rather than resolving all the incompatibilities, which wouldâ€™ve been a major undertaking in the monorepo, we decided to exclude these paths from Go modules instead. This was accomplished by <a href="https://github.com/golang/go/wiki/Modules%23can-an-additional-gomod-exclude-unnecessary-content-do-modules-have-the-equivalent-of-a-gitignore-file">placing an empty go.mod file</a> in the problematic paths.</p>

<h4 id="nested-modules">Nested Modules</h4>

<p>The empty <code class="language-plaintext highlighter-rouge">go.mod</code> file worked. This brought us to an important rule of Go modules, which is central to understanding many of the issues we encountered:</p>

<div>
 <p align="middle"><b><i>A module cannot contain other modules</i></b>
</p></div>

<p>This means that although the modules are within the same repository, Go modules treat them as though they are completely independent. When running <code class="language-plaintext highlighter-rouge">go mod</code> commands in the root of the monorepo, Go doesnâ€™t even â€˜seeâ€™ the other modules nested within.</p>

<h3 id="tackling-maintenance-issues">Tackling Maintenance Issues</h3>

<p>After completing the initial migration of our vendor directory to go mod vendor however, it opened up a different set of problems related to maintenance.</p>

<p>With Glide, we could guarantee that the Glide files and vendor directory would not change unless we deliberately changed them. This was not the case after switching to Go modules; we found that the <code class="language-plaintext highlighter-rouge">go.mod</code> file frequently required unexpected changes to keep our vendor directory reproducible.</p>

<p>There are two frequent cases that cause the <code class="language-plaintext highlighter-rouge">go.mod</code> file to need updates: <em>dependency inheritance</em> and <em>implicit updates</em>.</p>

<h4 id="dependency-inheritance">Dependency Inheritance</h4>

<p>Dependency inheritance is a consequence of Go modules <a href="https://github.com/golang/go/wiki/Modules%23is-gosum-a-lock-file-why-does-gosum-include-information-for-module-versions-i-am-no-longer-using">version selection</a>. If one of the monorepoâ€™s dependencies uses Go modules, then the monorepo inherits those version requirements as well.</p>

<p>When starting a new module, the default is to use the latest version of dependencies. This was an issue for us as some of our monorepo dependencies had not been updated for some time. As engineers wanted to import their module from the monorepo, it caused <code class="language-plaintext highlighter-rouge">go mod vendor</code> to pull in a huge amount of updates.</p>

<p>To solve this issue, we wrote a quick script to copy the dependency versions from one module to another.</p>

<p>One key learning here is to have other modules use the monorepoâ€™s versions, and if any updates are needed then the monorepo should be updated first.</p>

<h4 id="implicit-updates">Implicit Updates</h4>

<p>Implicit updates are a more subtle problem. The typical Go modules <a href="https://github.com/golang/go/wiki/Modules%23daily-workflow">workflow</a> is to use standard Go commands: <code class="language-plaintext highlighter-rouge">go build</code>, <code class="language-plaintext highlighter-rouge">go test</code>, and so on, and they will automatically update the <code class="language-plaintext highlighter-rouge">go.mod</code> file as needed. However, this was sometimes surprising, and it wasnâ€™t always clear why the <code class="language-plaintext highlighter-rouge">go.mod</code> file was being updated. Some of the reasons we found were:</p>

<ul>
  <li>A new import was added by mistake, causing the dependency to be added to the <code class="language-plaintext highlighter-rouge">go.mod</code> file</li>
  <li>There is a <a href="https://github.com/golang/go/wiki/Modules%23when-should-i-use-the-replace-directive">local replace</a> for some module B, and B changes its own <code class="language-plaintext highlighter-rouge">go.mod</code>. When thereâ€™s a local replace, it bypasses versioning, so the changes to Bâ€™s go.mod are immediately inherited.</li>
  <li>The build imports a package from a dependency that canâ€™t be satisfied with the current version, so Go attempts to update it.</li>
</ul>

<p>This means that simply <em>creating</em> a tag in an external repository is sometimes enough to affect the <code class="language-plaintext highlighter-rouge">go.mod</code> file, if you already have a broken import in the codebase.</p>

<h3 id="resolving-unexpected-dependencies-using-graphs">Resolving Unexpected Dependencies Using Graphs</h3>

<p>To investigate the unexpected dependencies, the command <code class="language-plaintext highlighter-rouge">go mod graph</code> proved the most useful.</p>

<p>Running <code class="language-plaintext highlighter-rouge">graph</code> with good old grep was good enough, but its output is also compatible with the <a href="https://godoc.org/golang.org/x/tools/cmd/digraph">digraph tool</a> for more sophisticated queries. For example, we could use the following command to trace the source of a dependency on <code class="language-plaintext highlighter-rouge">cloud.google.com/go</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ go mod graph | digraph somepath grab.com/example cloud.google.com/go@v0.26.0

github.com/hashicorp/vault/api@v1.0.4 github.com/hashicorp/vault/sdk@v0.1.13

github.com/hashicorp/vault/sdk@v0.1.13 google.golang.org/genproto@v0.0.0-20190404172233-64821d5d2107

google.golang.org/genproto@v0.0.0-20190404172233-64821d5d2107 google.golang.org/grpc@v1.19.0

google.golang.org/grpc@v1.19.0 cloud.google.com/go@v0.26.0
</code></pre></div></div>

<div class="post-image-section"><figure>
  <img src="/img/go-module-a-guide-for-monorepos-part-1/image1.png" alt="Diagram generated using modgraphviz" />
  <figcaption align="middle"><i>Diagram generated using modgraphviz</i></figcaption>
</figure></div>

<h2 id="stay-tuned-for-more">Stay Tuned for More</h2>
<p>I hope you have enjoyed this article. In our next post, weâ€™ll cover the other solutions we have for catching unexpected changes to the <code class="language-plaintext highlighter-rouge">go.mod</code> file and addressing dependency issues.</p>

<h2 id="join-us">Join us</h2>

<p>Grab is a leading superapp in Southeast Asia, providing everyday services that matter to consumers. More than just a ride-hailing and food delivery app, Grab offers a wide range of on-demand services in the region, including mobility, food, package and grocery delivery services, mobile payments, and financial services across over 400 cities in eight countries.</p>

<p>Powered by technology and driven by heart, our mission is to drive Southeast Asia forward by creating economic empowerment for everyone. If this mission speaks to you, <a href="https://grab.careers/">join our team</a> today!</p>

<h4 id="credits">Credits</h4>
<p><em>The cute Go gopher logo for this blogâ€™s cover image was inspired by Renee Frenchâ€™s original work.</em></p>
:ET