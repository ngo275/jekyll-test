I"’(<p>This is the first part of our series ‚ÄúDeep Dive into iOS Automation at Grab‚Äù, where we will cover testing automation in the iOS team. The second article is available <a href="/deep-dive-into-ios-automation-at-grab-continuous-delivery">here</a>.</p>

<p>Over the past two years at Grab, the iOS passenger app team has grown from 3 engineers in Singapore to 20 globally. Back then, each one of us was busy shipping features and had no time to set up a proper automation process. It was common to hear these frustrations from the team:</p>

<h4 id="travis-failed-again-but-it-passes-in-my-local">Travis Failed Again But it Passes in My Local</h4>

<p>There was a time when iOS 9 came out and Travis failed for us for every single integration. We tried emailing their support but the communication took longer than we would have liked, and ultimately we didn‚Äôt manage to fix the issue in time.</p>

<h4 id="fastlane-chose-the-wrong-provisioning-profile-again">Fastlane Chose the Wrong Provisioning Profile Again</h4>

<p>We relied on <a href="https://fastlane.tools/">Fastlane</a> for quite some time and it is a brilliant tool. However, there was a time when some of us had issues with provisioning profiles constantly. Why and how we moved away from Fastlane will be explained later.</p>

<h4 id="argh-if-more-people-tested-in-production-before-the-release-this-crash-might-have-been-caught">Argh, if More People Tested in Production Before the Release, This Crash Might have been Caught</h4>

<p>Prior to the app release, we do regression testing in a production environment. In the past, this was done almost entirely by our awesome QA team via Testflight distributions exclusively. That meant it was hard to cover all combinations of OSes, device models, locations and passenger account settings. We had prior incidents that only happened to a particular phone model, operating system, etc. Those gave us motivation to install a company-wide dogfooding program.</p>

<p>If you can relate to any of the above. This article is for you. We set up and developed most of the stuff below in-house, hence if you don‚Äôt have the time or manpower to maintain, it is still better to go with third-party services.</p>

<p>Testing and distribution are two aspects that we put a lot of effort in automating. Part I will cover how we do integration tests at Grab.</p>

<h3 id="testing---xcode-server">Testing - Xcode Server</h3>

<p>Besides being a complete Apple fan myself, there are a couple of other reasons why we chose Xcode Server over <a href="https://travis-ci.org/">Travis</a> and <a href="https://www.bitrise.io/">Bitrise</a> (which our Android team uses) to run our tests.</p>

<h4 id="faster-integration">Faster Integration</h4>

<p>Unlike most cloud services where every test is run in a random box from a macOS farm, at Grab, we have complete control of what machine we connect to. Provisioning a server (pretty much downloading Xcode, a macOS server, combined with some extremely simple steps) is a one-time affair and does not have to be repeated during each integration. e.g. Installing correct version of CocoaPods and command line libraries.</p>

<p>Instead of fresh cloning a repository, Xcode Server simply checks out the branch and pulls the latest code. That can save time especially when you have a long commit history.</p>

<h4 id="native-native-native">Native Native Native</h4>

<p>It is a lot more predictable. It guarantees that it‚Äôs the same OS, same Xcode version, same Swift version. If the tests passes on your Xcode, and on your teammates‚Äô Xcodes, it will pass on the server‚Äôs Xcode.</p>

<h4 id="perfect-ui-testing-process-recording">Perfect UI Testing Process Recording</h4>

<p>This is the most important reason and is something Travis / Bitrise didn‚Äôt offer at the time I was doing my research. When a UI test fails, knowing which line number caused it to fail is simply not enough. You would rather know what exactly happened. Xcode Server records every single step of your integration just like Xcode. You can easily skim through the whole process and view the screenshots at each stage. Xcode 8 even allows you to view a live screen on the Xcode Server while an integration is running.</p>

<p>For those of you who are familiar with UI testing on Xcode, you can view the results from the server in the exact same format. Clicking on the eye icon allows you to view the screenshots.</p>

<div class="post-image-section">
  <img alt="Xcode UI Tests" src="/img/ios-automation/xcode-ui-tests.png" />
</div>

<p>Sounds good! Let‚Äôs get started. On the day we got our server, we found creative ways to use it.</p>

<div class="post-image-section">
  <img alt="Mac Pro" src="/img/ios-automation/mac-pro.jpg" width="60%" />
  <small class="post-image-caption">Our multi-purpose server ‚ôªÔ∏è</small>
</div>

<h3 id="workflow">Workflow</h3>

<p>The basic idea is to create a bot when a feature branch is pushed, trigger the bot on each commit and delete the bot after the feature is merged / branch is deleted. Grab uses <a href="https://www.phacility.com/phabricator/">Phabricator</a> as the main code review tool. We wrote scripts to create and delete the bots as <a href="https://secure.phabricator.com/book/phabricator/article/arcanist/">Arcanist</a> post diff (branch is created/updated) and land (branch is merged) hooks.</p>

<div class="post-image-section">
  <img alt="Surprised Koala" src="/img/ios-automation/surprised-koala.jpg" width="60%" />
</div>

<p>Some PHP is still required. This is all of it üòπ:</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$botCommand</span> <span class="o">=</span> <span class="s2">"ruby bot.rb trigger </span><span class="nv">$remoteBranchName</span><span class="s2">"</span><span class="p">;</span>
</code></pre></div></div>

<p>Creating a bot manually is simply a <code class="language-plaintext highlighter-rouge">POST</code> request to your server with the bot specifications in body and authentication in headers. You can totally use <code class="language-plaintext highlighter-rouge">cURL</code>. We wrote it in Ruby:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">response</span> <span class="o">=</span> <span class="no">RestClient</span><span class="o">::</span><span class="no">Request</span><span class="p">.</span><span class="nf">execute</span><span class="p">(</span>
  <span class="ss">url: </span><span class="no">XCODE_SERVER_URL</span><span class="p">,</span>
  <span class="ss">method: </span><span class="s1">'post'</span><span class="p">,</span>
  <span class="ss">verify_ssl: </span><span class="kp">false</span><span class="p">,</span>
  <span class="ss">headers: </span><span class="vi">@headers</span><span class="p">,</span>
  <span class="ss">payload: </span><span class="n">body</span>
<span class="p">)</span>

<span class="k">if</span> <span class="n">response</span><span class="p">.</span><span class="nf">code</span> <span class="o">==</span> <span class="mi">201</span>
  <span class="nb">puts</span> <span class="s2">"Successfully created bot </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">, uuid </span><span class="si">#{</span><span class="n">uuid</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">return</span> <span class="no">JSON</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="n">response</span><span class="p">.</span><span class="nf">body</span><span class="p">)[</span><span class="s1">'_id'</span><span class="p">]</span>
<span class="k">else</span>
  <span class="nb">puts</span> <span class="s2">"Failed to create bot </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>
</code></pre></div></div>

<p>As you can see, <code class="language-plaintext highlighter-rouge">XCODE_SERVER_URL</code> is configurable. This is how we scale when the team expands.</p>

<p>Now the only thing left is to figure out the body payload. It is simple, all the bots and their configurations can be viewed as JSON via the following API. Simply create a bot via Xcode UI and it will reveal all the secrets:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="nt">-k</span> <span class="nt">-u</span> username:password https://your.server.com:20343/api/bots
</code></pre></div></div>

<p>Apple doesn‚Äôt have a lot of documentation on this. For a list of Xcode Server APIs you can try out <a href="http://docs.xcodeserverapidocs.apiary.io/#reference/bots/bots/create-a-new-bot">this list</a>.</p>

<h3 id="gotchas">Gotchas</h3>

<p>We have been happy with the server most of the time. However, along the way we did discover several downsides:</p>

<ul>
  <li>The simulator that the Xcode Server spins up does not necessarily have customised location enabled. You probably want to mock your locations in code in testing environment.</li>
  <li>
    <p>Installed builds are being updated during each integration and reused. There might be cache issues from previous integrations. Hence, deleting the app in your pre-integration script can be a good idea:</p>

    <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xcrun simctl uninstall booted your.bundle.id
</code></pre></div>    </div>
  </li>
  <li>Right after upgrading Xcode, you may face some transient issues. An example from what we‚Äôve observed so far is that existing bots often can‚Äôt find the simulators that used to be attached to them. Deleting old simulators and configuring new ones will help. That may also require you to change your bot creation script depending on your configuration. Restarting the server machine sometimes helps too.</li>
  <li>If you have one machine like us, there will be downtime during the software update. It either introduces inconvenience to your teammates or worse, someone could break master during the downtime.</li>
</ul>

<p>Stay tuned for the second part where we will cover on how we manage continuous delivery.</p>

<p><em>Many thanks to Dillion Tan and Tay Yang Shun who reviewed drafts and waited patiently for it to be published.</em></p>
:ET