I"<?<h1 id="introduction">Introduction</h1>

<p>Enabling the millions and millions of transactions and connections that take place every day on our platform requires data-driven decision making. And these decisions need to be made based on real-time data. For example, an experiment might inadvertently cause a significant increase of waiting time for riders.</p>

<p>Without the right tools and setup, we might only know the reason for this longer waiting time much later. And that would negatively impact our driver-partners’ livelihoods and our consumers’ Grab experience.</p>

<p>To overcome the challenge of retrieving information from large amounts of data, our first step was to adopt the open-source <a href="https://prestodb.io/">Facebook’s Presto</a>, that makes it possible to query petabytes with plain SQL. However, given our many teams, tools, and data sources, we also needed a way to reliably ingest and disperse data at scale throughout our platform.</p>

<p>To cope with our data’s scale and <a href="https://www.zdnet.com/article/volume-velocity-and-variety-understanding-the-three-vs-of-big-data/">velocity</a> (how fast data is coming in), we built two major systems:</p>

<ul>
  <li>
    <p>McD: Our scalable data ingestion and augmentation service.</p>
  </li>
  <li>
    <p>TalariaDB: A custom data store used, along with Presto and S3, by a scalable data querying engine.</p>
  </li>
</ul>

<p>In this article, we focus on TalariaDB, a distributed, highly available, and low latency time-series database that stores real-time data. For example, logs, metrics, and click streams generated by mobile apps and backend services that use Grab’s <a href="https://engineering.grab.com/feature-toggles-ab-testing">Experimentation Platform SDK</a>. It “stalks” the real-time data feed and only keeps the last one hour of data.</p>

<p>TalariaDB addresses our need to query at least 2-3 terabytes of data per hour with predictable low query latency and low cost. Most importantly, it plays very nicely with the different tools’ ecosystems and lets us query data using SQL.</p>

<p>The figure below shows how often a particular event happened within the last hour. The query scans through almost <strong>4 million rows</strong> and executes in about <strong>1 second</strong>.</p>

<p><img src="/img/big-data-real-time-presto-talariadb/query-event.png" alt="Query events" /></p>

<h1 id="design-goals">Design Goals</h1>

<p>TalariaDB attempts to solve a specific business problem by unifying cold and hot storage data models. This reduces overall latency, and lets us build a set of simple services that queries and processes data. TalariaDB does not attempt to be a general-purpose database. Simplicity was a primary design goal. We also set the following functional and non-functional requirements.</p>

<h2 id="functional-requirements">Functional Requirements</h2>

<ul>
  <li>
    <p><strong>Time-Series Metrics</strong>. The system can store thousands of different time-series metrics.</p>
  </li>
  <li>
    <p><strong>Data Retention</strong>. Keep the most recent data. This is configurable so we can extend the retention period on the fly.</p>
  </li>
  <li>
    <p><strong>Query or Aggregate by any dimension</strong>. We will build very complex queries using the full power of SQL and the Presto query engine for graphing, log retrieval, Grab Splainer, analytics, and other use-cases.</p>
  </li>
</ul>

<h2 id="non-functional-requirements">Non-functional Requirements</h2>

<ul>
  <li>
    <p><strong>Linear, Horizontal Scalability</strong>. The hot data layer can scale to a multi-terabyte or even multi-petabyte scale.</p>
  </li>
  <li>
    <p><strong>Low Latency</strong>. The system responds and retrieves data for a particular combination of metric name and time window. The query executes within a few seconds at most, even if there is a petabyte of data.</p>
  </li>
  <li>
    <p><strong>Simplicity</strong>. The system is simple, easy to write, understand, and maintain.</p>
  </li>
  <li>
    <p><strong>Availability</strong>. The system is an <strong>A</strong>vailable &amp; <strong>P</strong>artition tolerant system (AP in <a href="https://en.wikipedia.org/wiki/CAP_theorem">CAP</a> terms), always responding to queries even when some nodes are unavailable. For our purposes, partial data is better than no data.</p>
  </li>
  <li>
    <p><strong>Zero Operation</strong>. The system “just works”, with zero manual intervention. It needs to scale for the years to come.</p>
  </li>
  <li>
    <p><strong>High Write Throughput</strong>. Since both read and write throughput are high, we support at least <strong>one million events per second</strong> on a cluster.</p>
  </li>
  <li>
    <p><strong>Cost</strong>. Given the scale, the system should be as low cost as possible. Ideally, it should be as cheap as the SSDs and still be able to query terabytes or even petabytes of data with predictable, low latency.</p>
  </li>
</ul>

<h1 id="where-talariadb-sits-in-our-data-pipeline">Where TalariaDB Sits in Our Data Pipeline</h1>

<p>The figure below shows where TalariaDB fits in our event ingestion data pipeline’s architecture.</p>

<p><img src="/img/big-data-real-time-presto-talariadb/talariadb-data-pipeline.png" alt="TalariaDB data pipeline" /></p>

<p>To help you understand this schema, let’s walk through what happens to a single event published from mobile app or a backend service.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>xsdk.Track(ctx, "myEvent", 42, sdk.NewFacets().
    Passenger(123).
    Booking("ADR-123-2-001").
    City(10)
</code></pre></div></div>

<p>First, using the <strong>Track()</strong> function in our <a href="https://engineering.grab.com/feature-toggles-ab-testing">Golang, Android or iOS SDKs</a>, an engineer tracks a metric as follows:</p>

<ol>
  <li>
    <p>The tracked event goes into our McD Gateway service. It performs authentication if necessary, along with some basic enrichment (e.g. adding a unique event identifier). It then writes these events into our Kafka topic.</p>
  </li>
  <li>
    <p>The <strong>McD Consumer</strong> service reads from Kafka and prepares a <a href="https://orc.apache.org/">columnar ORC</a> file which is then <strong>partitioned by event name</strong>. In the example above, <em>myEvent</em> is pushed into its own file together with all the other <em>myEvents</em> which are ingested at more or less the same time. This happens in real time and is written to an S3 bucket every 30 seconds.</p>
  </li>
  <li>
    <p>A <a href="https://en.wikipedia.org/wiki/Apache_Spark">Spark</a> <strong>hourly job</strong> kicks in every hour to create massive columnar files used for cold/warm storage retrieval.</p>
  </li>
  <li>
    <p>The Presto query engine has both schemas registered letting users (people or systems) to perform <strong>sub-second queries</strong> on the data, and <strong>even combine the two schemas together by having a unified SQL layer</strong>.</p>
  </li>
</ol>

<h1 id="how-talariadb-is-designed">How TalariaDB is Designed</h1>

<p>Now, let’s look at TalariaDB and its main components.</p>

<p><img src="/img/big-data-real-time-presto-talariadb/talariadb-main-components.png" alt="TalariaDB main components" /></p>

<p>One of TalariaDB’s goals is simplicity. The system itself is <strong>not responsible for data transformation and data re-partitioning</strong> but only <strong>ingests</strong> and <strong>serves</strong> data to Presto.</p>

<p>To make sure TalariaDB scales to millions of events per second, it needs to leverage batching. A single event in TalariaDB is <strong>not stored as a single row</strong>. Instead, we store a <strong>pre-partitioned batch of events in a binary, columnar format</strong>. Spark streaming takes care of partitioning by event name (metric name) before writing to S3, making our design more streamlined and efficient.</p>

<p>You can see from the schema above, that the system really does only a few things:</p>

<ol>
  <li>
    <p>Listens to SQS S3 notifications of Put Object, downloading each file and writing it to an internal <a href="https://en.wikipedia.org/wiki/Log-structured_merge-tree">LSM Tree</a> with expiration.</p>
  </li>
  <li>
    <p>Performs periodic compaction and garbage collection to evict expired data. This is essentially done by the underlying <a href="https://en.wikipedia.org/wiki/Log-structured_merge-tree">LSM Tree</a>.</p>
  </li>
  <li>
    <p>Exposes an API for Presto by implementing <a href="https://prestodb.io/docs/current/connector/thrift.html">PrestoThriftConnector</a>.</p>
  </li>
</ol>

<p>We experimented with several different storage backends, and <a href="https://github.com/dgraph-io/badger">Badger key-value store</a> ended up winning our hearts. It’s an efficient and persistent log structured merge (LSM) tree based key-value store, purely written in Go. It is based upon the <a href="https://www.usenix.org/system/files/conference/fast16/fast16-papers-lu.pdf">WiscKey paper from USENIX FAST 2016</a>. This design is highly SSD-optimised and separates keys from values to minimise I/O amplification. It leverages both the sequential and the random performance of SSDs.</p>

<p>TalariaDB specifically leverages two of Badger’s unique features:</p>

<ol>
  <li>
    <p>Very <a href="https://blog.dgraph.io/post/badger-lmdb-boltdb/">fast key iteration and seek</a>. This lets us store millions of keys and quickly figure out which ones need to be retrieved.</p>
  </li>
  <li>
    <p>Separation of keys and values. We keep the full key space in memory for fast seeks. But iteration and our values are memory-mapped for faster retrieval.</p>
  </li>
</ol>

<h2 id="columnar-time-series-database">Columnar Time-series Database</h2>

<p>As mentioned, a single event in TalariaDB is not stored as a single row, but as a pre-partitioned batch of events in binary, columnar format. This achieves fast ingestion and fast retrieval. As data will be aligned on disk, only that column needs to be selected and sent to Presto. The illustration in the next section shows the difference. That being said, it is inefficient to store large amounts of data in a single column. For fast iteration, TalariaDB stores millions of individual columnar values (smaller batches) and exposes a combined “index” of metric name and time.</p>

<p>The query pattern we serve is key to understand why we do this. We need to answer questions such as:</p>

<ol>
  <li>
    <p>How many of a given event types are in a time window?</p>
  </li>
  <li>
    <p>What is an aggregate for a given metric captured on a specific event (e.g. count, average)?</p>
  </li>
  <li>
    <p>What are all the events for a passenger / driver-partner / merchant?</p>
  </li>
</ol>

<p>These use cases can be served with various <a href="https://www.slideshare.net/planetcassandra/bitmap-indexes">trickery</a> using a row based storage, but they require fairly complex and non-standard access patterns. We want to support anyone with an SQL client and SQL basic knowledge.</p>

<h2 id="data-layout--query">Data Layout &amp; Query</h2>

<p>TalariaDB combines a <a href="https://en.wikipedia.org/wiki/Log-structured_merge-tree">log-structured merge tree (LSMT)</a> and columnar values to provide fast iteration and retrieval of an individual event type within a given time window. The keys are lexicographically ordered. When a query comes, TalariaDB essentially seeks to the first key for that metric and stops iterating when either it finds the next metric or reaches the time bound. The diagram below shows how the query is processed.</p>

<p><img src="/img/big-data-real-time-presto-talariadb/query.png" alt="query" /></p>

<p>During the implementation, we had to reduce memory allocations and memory copies on read, which led us to implementing a zero-copy decoder. In other words, when a memory-mapped value is decoded, no data is copied around and we simply send it to PrestoDB as quickly and efficiently as possible.</p>

<h2 id="integrating-with-presto">Integrating with Presto</h2>

<p>TalariaDB is queryable using the <a href="https://prestodb.io/">Presto query engine</a> (or a thrift client implementing the Presto protocol) so we can keep things simple. To integrate TalariaDB and Presto, we leveraged the <a href="https://prestodb.io/docs/current/connector/thrift.html">Presto Thrift Connector</a>. To use the Thrift connector with an external system, you need to implement the PrestoThriftService interface. Next, configure the Thrift Connector to point to a set of machines, called Thrift servers, that implement the interface. As part of the interface implementation, the Thrift servers provide metadata, splits, and data. The Thrift server instances are assumed to be stateless and independent from each other.</p>

<p>What Presto essentially does is query one of the TalariaDB nodes and requests “data splits”. TalariaDB replies with a list of machines containing the query’s data. In fact, it simply maintains a <strong>membership list of all of the nodes</strong> (using the reliable Gossip protocol) and returns to Presto a list of all the machines in the cluster. We solve the bootstrapping problem by simply registering the full membership list at a random period in Route53.</p>

<p>Next, Presto hits every TalariaDB instance in parallel for data retrieval. Interestingly enough, by adding a new machine in the TalariaDB cluster we gain data capacity and reduce query latency at the same time. This is provided the Presto cluster has an equal or larger amount of executors to process the data.</p>

<p><img src="/img/big-data-real-time-presto-talariadb/integrating-with-presto.png" alt="Integrating with Presto" /></p>

<h2 id="scale-and-elasticity">Scale and Elasticity</h2>

<p>While scaling databases is not a trivial task, by sacrificing some of the requirements (such as strong consistency as per CAP), <strong>TalariaDB can scale horizontally</strong> by simply adding more hardware servers.</p>

<p>TalariaDB is not only highly available but also tolerant to network partitions. If a node goes down, data residing on the node becomes unavailable but new data will still be ingested and presented. We would much rather serve our consumers some data than no data at all. Going forward, we plan to transition the entire system to a <a href="https://kubernetes.io/">Kubernetes</a> <a href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/">StatefulSet</a> integration. This lets us auto-heal the TalariaDB cluster without data loss, as Kubernetes manages the data volumes.</p>

<p>We do <strong>upscaling</strong> by adding a new machine to the cluster. It automatically joins the cluster by starting gossiping with one of the nodes (discovery is done using a DNS record, Route53 in our case). Once the instance joins the cluster, it starts polling from a queue the files it has to ingest.</p>

<p><strong>Downscaling</strong> must be graceful, given we currently don’t replicate data. However, we can exploit that TalariaDB only stores data for the trailing time period. A graceful downscaling might be implemented by simply stopping ingesting new data but still serving data until everything the node holds is expired and storage is cleared. This is similar to how EMR deals with downscaling.</p>

<h2 id="conclusion">Conclusion</h2>

<p>We have been running TalariaDB in production for a few months. Together with some major improvements in our data pipeline, we have built a global real-time feed from our mobile applications for our analysts, data scientists, and mobile engineers by helping them monitor and analyse behaviour and diagnose issues.</p>

<p>We achieved our initial goal of fast SQL queries while ingesting several terabytes of data per hour on our cluster. A query of a single metric typically takes a few seconds, even when returning several million rows. Moreover, we’ve also achieved one minute of end-to-end latency: when we track an event on the mobile app, it can be retrieved from TalariaDB within one minute of its happening.</p>
:ET